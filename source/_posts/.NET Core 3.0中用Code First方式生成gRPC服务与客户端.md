---
layout: post
title: .NET Core 3.0中用 Code-First 方式创建 gRPC 服务与客户端
permalink: code-first-generate-gRPC-services-and-clients-in-dotnet-Core-3_0
updated: '2019-11-24 23:54:10'
date: 2019-11-24 23:54:10
tags:
- ASP.NET Core
- .NET Core
categories:
- .NET Core
---

## .NET Core love gRPC

千呼万唤的 .NET Core 3.0 终于在9月份正式发布，在它的众多新特性中，除了性能得到了大大提高，比较受关注的应该是 ASP.NET Core 3.0 对 gRPC 的集成了。
它的源码托管在 grpc-dotnet 这个 Github 库中，由微软 .NET 团队与谷歌 gRPC 团队共同维护.

.NET Core 对 gRPC 的支持在 grpc 官方仓库早已有实现（grpc/csharp），但服务端没有很好地与 ASP.NET Core 集成，使用起来还需要自己进行一些集成扩展。
而 ASP.NET Core 3.0 新增了 gRPC 服务的托管功能，能让 gRPC 与ASP.NET Core 框架本身的特性很好地结合，如日志、依赖注入、身份认证和授权，并由 Kestrel 服务器提供 HTTP/2 链接，性能上得到充分保障。

推荐把项目中已有的 RPC 框架或者内部服务间 REST 调用都迁移到 gRPC 上，因为它已经是云原生应用的标准 RPC 框架，在整个 CNCF 主导下的云原生应用开发生态里 gRpc 有着举足轻重的地位。

对于 gRPC 的使用方式，前段时间已经有其他大神写的几篇文章了，这里就不再赘述了。
本文主要介绍的是区别于标准使用规范的，但对.NET应用更加友好的使用方式，最后会提供源码来展示。

作为对比，还是要列一下标准的使用步骤：

1. 定义proto文件，包含服务、方法、消息对象的定义
2. 引入 `Grpc.Tools` Nuget 包并添加指定proto路径和生成模式
3. 生成项目，得到服务端的抽象类或客户端的调用客户端组件
4. 实现服务端抽象类，并在 ASP.NET Core 注册这个服务的路由端点
5. DI 注册 gRPC 服务。
6. 客户端用 `Grpc.Net.ClientFactory` Nuget 包进行统一配置和依赖注入

.NET Core 对 gRPC 的大力支持使开发者开发效率大大提高，入门难度也减少了许多，完全可以成为跟 WebApi 等一样的 .NET Core 技术栈的标配。

## proto 在单一语言系统架构中的局限性

使用 proto 文件的好处是多语言支持，同一份proto可以生成各种语言的服务和客户端，可以让用不同语言开发的微服务直接互相远程调用。但 proto 文件作为不同服务间的契约，不可以经常修改，否则就会对使用了它的服务造成不同程度的影响，因此对proto文件的版本控制需要得到重视。

另外，我们的应用程序还不应该与 gRPC 耦合，否则就会导致系统架构被这些实现细节所绑架。直接依赖 proto 文件和由它生成的代码，就是对 gRPC 的强耦合。

例如，当应用程序在演进的过程中，复杂度还未达到完全部署隔离的必要时，为了避免因“完全边界”引入的部署运维复杂性，又能预留隔离的可能性，需要有一层接口层作为“不完全边界”。

又比如，目前在 windows 系统的 iis 上还不支持 grpc-dotnet，当有windows上的程序需要使用 rpc，就需要换成 rest 的实现了。因此，为了不让应用程序对 gRPC 过于依赖，还应该使用一层抽象（接口）层与其解耦，用接口来隔离对 RPC 实现的依赖，这样在需要使用不同的实现时，可以通过注册不同的实现来方便地切换。

在这些场景下，本文要介绍的 Code-First gRPC 使用方法就发挥作用了。